<!-- # JWT 기반 인증 (AccessToken / RefreshToken)

JWT 기반 인증/인가(Authentication & Authorization)는 현대 웹 서비스에서 많이 사용되는 인증 방식이다.

JWT의 핵심은, 서버가 발급한 `사용자 신분증(JWT)`을 브라우저가 들고 다니면서, 요청마다 인증 정보를 증명하는 방식이다.
즉, HTTP가 stateless임에도 로그인 상태 유지가 가능해지도록 돕는다.

<br>

::: info 🧩 Reference

- `JWT(Json Web Token)` = 인증 정보를 담은 서명 가능한 토큰
- JWT 구조: `Header`.`Payload`.`Signature`
- AccessToken = 짧게 유지되는 신분증
- RefreshToken = 신분증 재발급용

:::

::: info 🧩 아래 정리를 하고 깨달은 점!

- AccessToken과 RefreshToken이 왜 둘 다 필요한지
- AccessToken이 왜 짧게 만료돼야 하는지
- RefreshToken을 왜 httpOnly 쿠키로 관리해야 하는지
- 401이 왜 토큰 재발급 신호인지
- 자동 로그인이 내부적으로 어떻게 구현되는지
- Axios interceptor가 왜 필요한지

:::

<br>

## JWT를 이해하기 전에 중요한 사실

JWT는 독립적으로 동작하는 기술이 아니라,
`HTTP + HTTPS + Cookie + Authorization Header` 위에서 돌아가는 인증 프로토콜이다.

즉 인증을 구현할 때,

- 토큰 → HTTP Authorization 헤더로 보내고
- RefreshToken → httpOnly 쿠키로 자동 전송되고
- 토큰 만료 → HTTP 401 응답으로 감지되고
- 자동 재발급 → Axios interceptor로 구현되는 것

→ 이 모든 과정이 HTTP 규약 위에서 이루어진다.
(그래서 HTTP/HTTPS, 쿠키 동작을 먼저 이해하면 JWT를 훨씬 쉽게 이해할 수 있다.)

::: info 🧩 `Axios`를 사용하지 않으면 어떻게 될까?

본문에서 설명하는 흐름은 Axios 기준이지만,
JWT 인증 자체는 Axios 의존적인 기술이 아니라 `HTTP 규약 위에서 동작하는 인증 방식`이다.
현재 진행 중인 프로젝트가 Axios를 사용하고 있어 이를 기준으로 적었다!

- AccessToken → Authorization 헤더로 보내고
- RefreshToken → httpOnly 쿠키로 자동 전송되고
- AccessToken 만료 → 서버가 401을 내려주고
- RefreshToken 재발급 → fetch로도 가능

따라서 JWT 인증은 Axios 기능이 아니라 HTTP 규약 위에서 동작하는 인증 방식이다.
Axios를 쓰지 않는다면, interceptor 부분만 직접 함수로 감싸서 구현하면 동일하게 동작한다!

:::

<br>

## JWT란?

JWT(Json Web Token)는 인증 정보를 담은 짧고 가벼운 문자열이다.
`Signature`가 있기 때문에 위·변조가 불가능한 토큰이다.

```plaintext
Header.Payload.Signature
```

| 부분        | 설명                              |
| ----------- | --------------------------------- |
| `Header`    | 토큰 형식, 서명 알고리즘 정보     |
| `Payload`   | 실제 데이터(userId, role, exp 등) |
| `Signature` | 비밀키로 서명된 값 → 위조 방지    |

서버는 Signature를 검증해 `이 토큰이 우리 서버에서 발급된 토큰인지?`, `Payload가 유효한지?`를 판단할 수 있다.
그래서 세션 저장소 없이도 인증이 가능하다. (stateless)

<br>

## AccessToken과 RefreshToken이 필요한 이유

JWT는 유효기간이 있는 일회성 토큰이기 때문에 다음 문제가 생긴다:

- AccessToken을 길게 하면 → 탈취 위험 증가
- AccessToken을 짧게 하면 → 사용자가 자주 로그아웃됨

그래서 나온 구조가 AccessToken (짧게) + RefreshToken (길게)이다.

<br>

## AccessToken + RefreshToken 구조

| 종류         | 저장 위치                         | 만료       | 역할               |
| ------------ | --------------------------------- | ---------- | ------------------ |
| AccessToken  | 메모리/Zustand/localStorage       | 15분~1시간 | 요청 인증          |
| RefreshToken | httpOnly 쿠키(브라우저 자동 관리) | 2주~1달    | AccessToken 재발급 |

- AccessToken → 짧게: 토큰이 털리더라도 피해 최소화
- RefreshToken → 길게: 자동 로그인 유지

두 개가 합쳐져서 보안 + 유저 경험 둘 다 잡는 구조가 된다.

<br>

## RefreshToken이 `쿠키`여야 하는 이유

RefreshToken은 클라이언트의 신원(Identity)을 증명하는 데이터이기 때문에 프론트가 직접 저장하거나 관리하면 안 된다.
브라우저가 자동으로 관리하는 httpOnly 쿠키여야 한다.

#### 1. RefreshToken은 서버가 신원을 판단하는 인증 채널이어야 한다.

- 서버가 RT를 통해 “이 재발급 요청이 진짜 우리 사용자가 보낸 요청인지” 판단한다.

쿠키는 서버가 Set-Cookie로 내려주면 브라우저가 자동 저장 + 자동 전송해주므로
프론트 코드 개입 없이 안정적인 인증 채널을 유지할 수 있다.

#### 2. RefreshToken은 JS에서 읽히면 안 된다.

RT를 localStorage 같은 곳에 저장하면 악성 스크립트가 삽입되는 순간 바로 털린다.
httpOnly 쿠키는 JS로 접근할 수 없기 때문에 XSS 공격으로부터 RefreshToken을 보호하는 유일한 방법이다.

#### 3. RT는 재발급 용도라 노출되면 세션이 영구 탈취된다.

- AccessToken은 짧아서 피해가 제한적이다.
- RefreshToken은 길어서 털리면 치명적이므로 무조건 보호해야 한다.

그래서 RT는 반드시,
`RefreshToken = httpOnly + Secure + SameSite 쿠키` 이 조합으로 보호해야 한다.

<br>

## 정리

::: info 💡

- JWT 인증은 HTTP/HTTPS + Authorization 헤더 + Cookie 위에서 동작한다.
- AccessToken은 요청 인증용이며, 보안을 위해 짧게 유지해야 한다.
- RefreshToken은 재발급용이며, httpOnly 쿠키로 반드시 보호해야 한다.
- AccessToken이 만료되면 서버는 401 Unauthorized를 내려 신호를 보낸다.
- 이 신호를 받아 RefreshToken으로 재발급 → 요청 재시도 흐름이 시작된다.
- Axios를 사용할 경우, interceptor가 이 재발급 과정을 자동화하는 도구가 된다.

::: -->
