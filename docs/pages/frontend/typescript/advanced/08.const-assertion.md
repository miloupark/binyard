# 상수 단언 (Const Assertion)

`as const` 문법은 값을 리터럴 타입으로 고정하고, `읽기 전용`으로 만드는 TypeScript의 단언 기능이다.
즉, “이 값은 변경되지 않는다” 라는 의도를 타입 수준에서 명시한다.

<br>

## 1. 기본 문법

```ts
// 객체
const objName = {} as const;

// 배열
const arrName = [] as const;
```

- `as const`는 확장할 수 없는 리터럴 타입으로 변환한다.
- 변수가 변하지 않음을 컴파일러에 알려, 더 정확한 타입 추론과 `불변성`을 보장한다.

<br>

## 2. 객체 예시

```ts
const book = {
  title: "TypeScript Guide",
  author: "coding zzang",
} as const;

book.title = "another zzang"; // Error: 읽기 전용 속성
```

- `as const`를 사용하면 `book.title`의 타입이 단순한 string이 아니라 `TypeScript Guide` 리터럴로 고정된다.
- 따라서 속성 수정 불가, 값이 그대로 유지된다.

<br>

## 3. 배열 예시

```ts
const nums = [1, 2, 3, 4, 5] as const;
numbs.push(6); // Error: 읽기 전용 배열
```

- `as const`를 붙이면 배열도 `읽기 전용 튜플`로 바뀐다.
- 즉, `readonly [1, 2, 3, 4, 5]` 형태로 타입이 추론된다.

<br>

## 4. 객체 리터럴의 안정적 추론

```ts
const config = {
  server: "https://api.somedomain.com",
  port: 8080,
  version: 2,
} as const;

config.server = "https"; // Error
```

- 각 속성이 변경 불가능한 리터럴 타입으로 추론된다.
- 이를 통해 애플리케이션 전역에서 안전하고 일관된 설정을 유지할 수 있다.

<br>

## 5. keyof + typeof 조합 예시

`as const`는 `keyof` / `typeof` 조합과 함께 사용할 때 특히 강력하다.
객체의 키를 그대로 타입으로 추출할 수 있다.

```ts
// 주문 상태 코드 매핑
const statusCodeMap = {
  101: "ordered",
  102: "pending",
  103: "completed",
} as const;

// key 타입 추출
export type StatusCodeKeys = keyof typeof statusCodeMap;
// "101" | "102" | "103"

function handleStatus(statusCode: StatusCodeKeys) {
  const message = statusCodeMap[statusCode];

  // UI 업데이트 or 로직 처리
  console.log(message);
}
```

- `keyof` `typeof` 패턴은 객체의 실제 키를 기반으로 타입을 생성한다.
- `as const` 덕분에 키(101, 102, 103)가 숫자가 아닌 리터럴 문자열 타입으로 안전하게 유지된다.
