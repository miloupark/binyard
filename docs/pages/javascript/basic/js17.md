# async / await

자바스크립트에서 비동기 작업을 처리할 때 가장 기본적인 방식은 `Promise`와 `.then()`을 사용하는 것이다.
하지만 .then()이 중첩되거나 체이닝이 길어지면 코드의 흐름을 따라가기 어려워지고, 가독성도 떨어지게 된다.
이러한 문제를 해결하기 위해 도입된 문법이 async와 await이다.

`async / await`은 비동기 코드를 `동기 코드처럼 순차적으로 작성할 수 있도록 해주는 문법`이다.
복잡한 비동기 흐름도 간결하게 표현할 수 있어 코드의 가독성과 유지보수성을 크게 높여준다.

- .then() 체이닝보다 가독성이 좋다
- 예외 처리도 try-catch로 간단하게 관리할 수 있다
- 중첩 없이 위에서 아래로 흐르는 구조로 코드를 작성할 수 있다

결과적으로 async / await은 `가독성, 예외 처리, 유지보수` 측면에서 우수하기 때문에 현재 가장 많이 사용되는 비동기 처리 방식 중 하나이다.

<br>

```less
async / await
├── async / await
└── try-catch (예외 처리)
```

<br>

## async / await

```js
async function 함수이름() {
  const result = await 비동기함수();
  return result;
}
```

### async

```js
// Promise와 .then()을 사용한 기본적인 비동기 처리 코드
const delay = (ms) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};

const start = () => {
  delay(2000).then(() => {
    console.log("대기");
  });
};

start();
```

- delay 함수는 지연 시간을 인수로 받아 setTimeout을 Promise로 감싼 비동기 함수이다. 일정 시간이 지난 후 resolve()를 호출해 흐름을 제어한다.
- start 함수는 delay가 끝난 뒤 .then() 메서드를 통해 "대기"라는 메시지를 출력한다.
- 위 코드는 async 키워드를 사용해 더 직관적으로 변경할 수 있다.

```js
const delay = (ms) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};

const start = async () => {
  return "대기";
};

start().then((result) => {
  console.log(result);
});

// 대기
```

- `async`는 비동기 함수임을 나타내는 키워드로, 함수 앞에 붙이면 해당 함수는 자동으로 Promise를 반환하는 비동기 함수가 된다.
- async 함수 내부에서 return한 값은 자동으로 Promise로 감싸져 반환되며, 이는 마치 resolve()를 호출한 것과 같은 효과를 낸다. 이 결과는 .then()을 통해 이어서 처리할 수 있다.

<br>

### async / await

```js
const delay = (ms) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};

const start = async () => {
  await delay(2000); // delay 함수가 처리 완료될 때까지 기다림
  console.log("대기");
};

start();
```

- `await`은 `async 함수 내부`에서만 사용할 수 있는 키워드이다.
- await 앞에 오는 Promise가 처리될 때까지 기다린 뒤, 다음 줄의 코드를 실행한다.
- 덕분에 비동기 작업도 동기 코드처럼 위에서 아래로 순차적으로 작성할 수 있게 된다.

<br>

## try-catch

async / await을 사용할 때는 `try-catch` 문을 활용해 비동기 작업 중 발생할 수 있는 에러를 안전하게 감지하고 처리할 수 있다. 여러 개의 await가 있는 경우, 한 곳에서 에러를 처리할 수 있어 코드가 깔끔해진다. 코드 흐름이 중단되지 않고, 예외가 발생해도 이후 로직을 유연하게 이어갈 수 있다.<br>
이는 Promise의 .catch()와 같은 역할을 하며, 예외 상황을 보다 구조적으로 다룰 수 있게 해준다.

```js
async function 작업() {
  try {
    const result = await something();
    console.log(result);
  } catch (err) {
    console.error(err);
  }
}
```

```js
const delay = (ms) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};

const start = async () => {
  try {
    await delay(2000);
    console.log("대기");
  } catch (error) {
    console.log(error);
  }
};

start();
```

- try 블록 안의 코드가 실행되며, 이 과정에서 에러가 발생하면 즉시 catch 블록으로 흐름이 넘어간다.
- 발견된 에러는 catch(error)의 error 객체에 담기며, 이를 통해 에러의 원인을 확인할 수 있다.
