# 배열 (Array)

배열은 여러 개의 값을 하나의 변수에 순서대로 저장할 수 있는 자료구조이다. 자바스크립트에서 배열은 값의 순서가 중요한 데이터 집합을 효율적으로 관리하는 데 사용된다. 숫자, 문자열, 객체 등 다양한 타입의 값을 저장할 수 있으며, 각 요소는 숫자 인덱스를 통해 접근한다.

```less {1}
배열 (Array)
├── 배열 생성 방법
│   ├── 생성자 함수 방식 (Constructor Function)
│   └── 배열 리터럴 방식 (Array Literal)
└── 배열 요소 조작
    ├── 배열 요소 출력
    ├── 배열 요소 추가
    │   ├── push(): 배열의 마지막 인덱스에 요소 추가
    │   └── unshift(): 배열의 첫 번째 인덱스에 요소 추가
    ├── 배열 요소 수정
    ├── 배열 요소 삭제
    │   ├── pop(): 배열의 마지막 요소 삭제
    │   ├── shift(): 배열의 첫 번째 요소 삭제
    │   └── splice(): 배열에서 특정 인덱스의 요소 삭제 (+ 추가/교체)
    └── 배열 길이 확인
        └── length: 배열의 전체 요소 개수 확인 및 배열 크기 조절
```

### 배열의 특징

- `0부터 시작하는 인덱스`: 배열의 요소는 인덱스를 기준으로 접근하며, 인덱스는 항상 0부터 시작한다.
- `순서가 있는 데이터 구조`: 배열은 각 요소가 삽입된 순서를 유지하며 저장되므로, 순차적 데이터 처리에 적합하다.
- `동적 크기`: 자바스크립트의 배열은 정해진 크기가 없으며, 요소를 추가하거나 제거하면 크기가 자동으로 조절된다.
- `객체의 특수한 형태`: 배열은 객체(Object)의 일종으로, 인덱스를 키(key)처럼 사용하지만 배열 전용 메서드와 속성이 제공되어, 데이터를 직관적으로 다룰 수 있다.

## 배열 생성 방법

```less {1}
배열 생성 방법
├── 생성자 함수 방식 (Constructor Function)
└── 배열 리터럴 방식 (Array Literal)

```

### (1) 생성자 함수 방식 (Constructor Function)

`new` 키워드를 사용해 `Array` 생성자 함수를 호출하면 배열을 생성할 수 있다. 하지만 전달하는 인자의 개수에 따라 동작 방식이 달라지기 때문에, 직관성이 떨어져 잘 사용되진 않는다.

```js
let arr = new Array(); // 빈 배열 생성

console.log(arr); // []
```

```js
// 여러 개의 값을 넣으면, 각각 배열의 요소로 들어간다.
let array1 = new Array(1, 2, 3);
console.log(array1); // [1, 2, 3]

// 숫자 하나만 넣으면, 그 길이만큼 비어 있는 배열이 만들어진다.
let array2 = new Array(3);
console.log(array2); // [비어 있음 x 3]
```

- 배열 생성자 new Array()는 여러 개의 값을 넣으면 각각 배열 요소가 된다. 숫자를 하나만 넣으면 그 숫자만큼 길이가 비어있는 배열이 만들어진다.

<br>

### (2) 배열 리터럴 방식 (Array Literal)

`[]`대괄호를 사용하여 배열을 직접 선언 방식으로, 가장 많이 사용되는 배열 생성 방법이다.

```js
let array1 = [];

console.log(array1); // []
```

```js
let array1 = [1, 2, 3];
console.log(array1); // [1, 2, 3]

let array2 = [3];
console.log(array2); // [3]
```

- 배열 리터럴을 사용하면 `[]` 안에 값을 나열하여 배열을 생성할 수 있다.
- 배열의 요소들은 작성한 순서대로 저장되며, 인덱스를 통해 접근 가능하다.
- 배열은 숫자, 문자열, 객체, 함수 등 어떤 자료형도 요소로 가질 수 있다.

#### `배열 요소에 다양한 자료형 넣기`

```js
let arr = [
  { name: "바켸빈" },
  1,
  "array",
  function () {
    console.log("hello world!");
  },
  null,
  undefined,
];

console.log(arr);
// [{ name: "바켸빈" }, 1, "array", ƒ () { console.log("hello world!"); }, null, undefined]
```

- 배열은 다양한 자료형의 데이터를 동시에 담을 수 있는 유연한 구조를 가지고 있다.

<br>

## 배열 요소 조작

배열은 데이터가 위치한 순서인 인덱스를 통해 배열 요소에 접근한다. 배열의 인덱스는 0번부터 시작한다.

```less {1}
배열 요소 조작
├── 배열 요소 출력
└── 배열 요소 추가
│   ├── push(): 배열의 마지막 인덱스에 요소 추가
│   └── unshift(): 배열의 첫 번째 인덱스에 요소 추가
├── 배열 요소 수정
└── 배열 요소 삭제
│   ├── pop(): 배열의 마지막 요소 삭제
│   ├── shift(): 배열의 첫 번째 요소 삭제
│   └── splice(): 배열에서 특정 인덱스의 요소 삭제
└── 배열 길이 확인
    └── length: 배열의 전체 요소 개수 반환
```

<br>

### (1) 배열 요소 출력

```js
let arr = [1, "hello", null];

console.log(arr[0]); // 1
console.log(arr[1]); // "hello"
console.log(arr[2]); // null
```

- 배열의 요소를 출력하기 위해서는 `배열이름[인덱스 번호]`를 작성하면 된다.

<br>

### (2) 배열 요소 추가

```less {1}
배열 요소 추가
├── push(): 배열의 마지막 인덱스에 요소 추가
└── unshift(): 배열의 첫 번째 인덱스에 요소 추가
```

### push() 메서드

push()는 배열의 내장 메서드로, 전달한 값을 배열의 맨 뒤에 추가한다. 배열 이름 뒤에 `.push()`를 붙이고, 괄호 안에 추가할 값을 전달하면 된다.

```js
let arr = [1, "hello", null];

arr.push(10);
console.log(arr); // [1, "hello", null, 10]
```

- `arr.push(10)`은 숫자 10을 배열의 마지막에 추가한다. 배열의 길이도 함께 증가한다.

### unshift() 메서드

unshift()는 배열의 내장 메서드로, 전달한 값을 배열의 맨 앞에 추가한다.

```js
let arr = [1, "hello", null];

arr.unshift(5);
console.log(arr); // [5, 1, "hello", null]
```

- `arr.unshift(5)`은 숫자 5를 배열의 첫 번째 요소로 추가한다. 기존 요소들은 한 칸씩 뒤로 밀리며, 배열의 길이도 함께 증가한다.

<br>

### (3) 배열 요소 수정

배열은 전체를 새로운 값으로 재할당하거나, 인덱스를 통해 특정 요소를 직접 수정할 수 있다.

```js
let color = ["black", "white", "brown"];

// 새로운 배열 재할당
color = ["black", "blue", "brown"];
// 배열의 3번째 요소 수정
color[2] = "yellow";

console.log(color); // ['black', 'blue', 'yellow']
```

#### `const로 선언된 배열의 요소 변경`

```js
const color = ["black", "white", "brown"];

// 배열 자체를 재할당하려고 하면 에러 발생: TypeError
color = ["black", "blue", "brown"];

// 배열 내부 요소는 수정 가능
color[2] = "yellow";

console.log(color); // ['black', 'white', 'yellow']
```

- 자바스크립트에서 배열은 객체의 일종으로(참조 타입)이기 때문에, const로 선언된 배열이라도 내부의 요소는 자유롭게 수정할 수 있다. 이는 배열 전체가 아닌, 배열이 가리키는 참조값(메모리 주소)은 그대로 유지되고, 그 내부 데이터만 바뀌기 때문이다.
- const로 선언된 배열은 재할당이 불가능하다. 따라서 `color = ["black", "blue", "brown"]`과 같은 재할당은 에러가 발생한다.

<br>

### (4) 배열 요소 삭제

```less {1}
배열 요소 삭제
├── pop(): 배열의 마지막 요소 삭제
├── shift(): 배열의 첫 번째 요소 삭제
└── splice(): 배열에서 특정 인덱스의 요소 삭제
```

### pop() 메서드

pop()은 배열의 마지막 요소를 제거하고, 제거된 값을 반환하는 배열 내장 메서드이다.
이 메서드는 원본 배열을 변경한다.

```js
const arr = [1, "hello", null];
arr.pop();

console.log(arr); // [1, "hello"]
```

- 마지막 요소 `null`이 제거되어, 배열은 `[1, "hello"]`가 된다.

```js
const arr = [1, "hello", null];
const removed = arr.pop();

console.log(removed); // null
```

- `pop()` 메서드는 삭제된 요소를 반환하므로, 이 값을 변수에 저장할 수 있다.

<br>

### shift() 메서드

배열의 첫 번째 요소를 제거할 때는 shift()라는 배열 내장 메서드를 사용한다.
삭제된 요소는 반환되며, 원본 배열은 변경된다.

```js
const arr = [1, "hello", null];
arr.shift();

console.log(arr); // ["hello", null]
```

- shift()는 배열의 첫 번째 요소인 `1`을 제거하고, 나머지 요소들을 앞으로 이동시킨다.
  제거된 값은 반환되며, 필요할 경우 변수에 저장할 수 있다.

```js
const arr = [1, "hello", null];
const removed = arr.shift();

console.log(removed); // 1
console.log(arr); // ["hello", null]
```

- shift() 메서드는 제거된 요소인 `1`을 반환하고, arr 배열은 첫 번째 요소가 제거된 상태로 변경된다.

<br>

### splice() 메서드

splice()는 배열에서 요소를 삭제하거나, 새로운 요소를 추가하거나, 기존 요소를 교체할 수 있는 배열 내장 메서드다.
이 메서드는 원본 배열을 직접 변경하며, 삭제된 요소를 배열로 반환한다.

```js
array.splice(start, deleteCount, item1, item2, ...)
```

- splice는 `start`와 `deleteCount` 두 개의 인수를 받는다.
- `start`: 변경을 시작할 인덱스
- `deleteCount`: 제거할 요소의 갯수 (0으로 작성 시 삭제는 하지 않고 추가할 요소들이 그 위치에 삽입된다.)
- `item1, item2, ...`: 삭제한 자리에 추가할 요소들 (생략 시 삭제만 수행)

#### `요소 삭제`

```js
const fruits = ["apple", "banana", "cherry", "date"];
fruits.splice(1, 3);

console.log(fruits); // ["apple"]
```

- 인덱스 1부터 시작해 총 3개의 요소를 삭제한다.
- `splice(1, 3)`은 배열의 두 번째 요소부터 시작해서 총 3개 요소를 삭제하며, 이때 시작 인덱스(1)에 위치한 "banana"도 삭제 대상에 포함된다.

#### `삭제된 요소 반환`

```js
const fruits = ["apple", "banana", "cherry", "date"];
const removed = fruits.splice(1, 2);

console.log(removed); // ["banana", "cherry"]
console.log(fruits); // ["apple", "date"]
```

- 삭제된 요소는 splice()의 반환값으로 받을 수 있으며, 배열로 제공된다.

#### `요소 추가 및 교체`

```js
const fruits = ["apple", "banana", "cherry", "date"];
fruits.splice(1, 2, "pineapple", "strawberry");

console.log(fruits); // ["apple", "pineapple", "strawberry", "date"]
```

- 인덱스 1부터 2개 삭제 후, 새 요소가 추가된다.

#### `삭제 없이 요소 삽입`

```js
const fruits = ["apple", "banana", "cherry"];
fruits.splice(1, 0, "pineapple");

console.log(fruits); // ["apple", "pineapple", "banana", "cherry"]
```

- `splice(1, 0, "pineapple")`는 인덱스 1에 "pineapple"을 삽입하고, 아무 요소도 삭제하지 않는다.
  "banana"와 "cherry"는 뒤로 밀리게 됩니다.

<br>

### (5) 배열 길이 확인

### length

배열의 요소 개수를 확인할 때는 `length` 프로퍼티를 사용한다.
배열의 길이는 요소의 개수를 기준으로 자동으로 계산되며, 인덱스의 최대값보다 1 큰 값이 된다.

```js
const fruits = ["apple", "banana", "cherry", "date"];

console.log(fruits.length); // 4
```

- length는 배열의 마지막 인덱스 + 1 값과 동일하다.

```js
const fruits = ["apple", "banana", "cherry", "date"];
fruits.pop();

console.log(fruits); // ["apple", "banana", "cherry"]
console.log(fruits.length); // 3
```

- pop() 메서드는 배열의 마지막 요소 "date"를 제거한다. 이로 인해 배열의 크기는 4에서 3으로 줄어든다.
- length 프로퍼티는 자동으로 갱신되어, 변경된 배열의 길이인 3을 반환한다.

```js
const empty = [];
console.log(empty.length); // 0
```

- 빈 배열의 경우 length는 0이다.

<br>

### length 프로퍼티를 이용한 배열 크기 조정

`length` 프로퍼티는 읽기 전용이 아니기 때문에 직접 값을 변경하면 배열의 길이를 인위적으로 조정할 수 있다.
이를 활용하면 배열을 잘라내거나 비우는 등의 작업도 가능하다.

::: details `length는 읽기 전용이 아니다` 무슨 뜻일까?
자바스크립트에서 어떤 프로퍼티가 "읽기 전용(read-only)"이 아니다라는 말은, 그 값을 개발자가 직접 바꿀 수 있다는 뜻이다.

<br>
읽기 전용이 아닌 경우 (변경 가능)

```js
let arr = [1, 2, 3];
arr.length = 1; // 길이를 줄임

console.log(arr); // [1]
```

- `arr.length = 1`은 배열의 길이를 강제로 줄인 것으로, 실제로 배열이 잘려 나간다.
- 즉, length는 단순히 정보를 제공하는 프로퍼티가 아니라, 배열 구조를 제어하는 수단이기도 하다.

<br>
읽기 전용인 경우 (변경 불가능)

```js
const PI = 3.14;
PI = 3.14159; // TypeError: Assignment to constant variable.
```

- const로 선언된 값은 변경할 수 없기 때문에 에러가 발생한다. 이런 값이 진짜 읽기 전용이다.

:::

#### `배열 길이 줄이기`

배열의 length 값을 현재보다 작게 설정하면, 해당 길이 이후의 요소는 모두 삭제된다.

```js
const fruits = ["apple", "banana", "cherry", "date"];
fruits.length = 2;

console.log(fruits); // ["apple", "banana"]
```

- 인덱스 2 이상의 요소 "cherry", "date"는 잘려 나간다.

#### `배열 비우기`

배열을 비우는 가장 간단한 방법 중 하나는 length를 0으로 설정하는 것이다.

```js
let arr = [1, 2, 3, 4, 5];
arr.length = 0;

console.log(arr); // []
```

#### `배열 길이 늘리기`

length를 현재보다 크게 설정하면, 비어 있는 요소(undefined) 가 뒤에 추가된다.

```js
let arr = [1, 2];
arr.length = 5;

console.log(arr); // [1, 2, 비어 있음 x 3]
```

- 하지만 이렇게 늘어난 공간은 실제 값이 없는 "비어 있는 슬롯" 으로, 반복문 등에서는 건너뛰는 경우도 있으니 주의가 필요하다.
