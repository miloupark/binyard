# Data Types

```plaintext {8,14,15,16}
Data Type
├── Primitive Type 기본형
│   ├── Number
│   ├── String
│   ├── Boolean
│   ├── null
│   ├── undefined
│   └── Symbol
└── Reference Type 참조형
    └── Object
        ├── Array
        ├── Function
        ├── RegExp(Regular Expression)
        ├── Set / WeakSet
        ├── Map / WeakMap
        └── ...

※ 표시된 데이터 타입은 ES6(ECMAScript 2015)에서 도입된 것
```

## 자바스크립트 메모리 구조

```plaintext {2,6}
JavaScript Memory
├── Stack Memory
│   ├── 변수
│   ├── Primitive Type: 값 자체 저장
│   └── 정적 할당: 실행 시 고정된 크기로 메모리 할당
└── Heap Memory
    ├── Reference Type: 주소를 통해 데이터 참조
    └── 동적 할당: 런타임 중 필요에 따라 메모리 확보
```

- 기본형은 Stack에 값 자체가 저장되고, 참조형은 Heap에 데이터를 저장하고 Stack엔 주소가 저장된다.
- Stack은 접근 속도가 빠르지만 공간이 제한적이고, Heap은 유연하지만 접근 속도가 느리다.
- 이 구조를 이해하면 다음과 같은 차이를 쉽게 파악할 수 있다. <br>
  : 기본형은 값 자체가 복사되어 완전히 분리된다.<br>
  : 참조형은 같은 객체를 가리키므로 복사해도 함께 바뀐다.<br>
  : 참조형은 Heap에 데이터를 저장하고 Stack에는 주소를 저장하기 때문에, 메모리 할당 과정에서 한 단계를 더 거친다. 이로 인해 기본형은 직접 값을 다루는 반면, 참조형은 주소를 통해 간접적으로 데이터를 다룬다.

<br>

### 기본형은 왜 변수 간 영향이 없을까? (Stack에 값 자체 저장)

```js
let a = 10;
let b = a;
b = 20;
```

```less
Stack
┌────────────┐
│ a = 10     │ ← 값 자체 저장
│ b = 10     │ ← a의 값을 복사
└────────────┘

b 값을 20으로 바꾸면,
┌────────────┐
│ a = 10     │
│ b = 20     │ ← b만 바뀜 (a는 영향 없음)
└────────────┘

```

- 기본형은 값 자체를 복사해서 저장하므로 변수 간 독립적이다.

<br>

### 참조형은 왜 같이 바뀔까? (Heap에 객체 저장, 주소만 복사됨)

```js
let obj1 = { name: "Binny" };
let obj2 = obj1;
obj2.name = "Hoon";
```

```css
Stack
┌─────────────────────────────┐
│ obj1 ─┐                     │
│ obj2 ─┘                     │ ← 두 변수는 동일한 주소를 가리킴
└──────┬──────────────────────┘
       ↓
Heap
┌─────────────────────────────┐
│ { name: "Hoon" }            │ ← 실제 객체 데이터
└─────────────────────────────┘
```

- 참조형은 Heap에 데이터를 저장하고 Stack엔 주소가 저장된다.
- obj1과 obj2는 Stack에 각각 존재하지만, 같은 Heap 주소를 참조하기 때문에 하나의 객체를 공유하게 된다.
- 변수 간 복사는 데이터 복사가 아니라 주소 복사이므로, 한 변수를 수정하면 다른 변수에도 영향을 줄 수 있다.

<br>

### 중첩 객체 - 객체 내부의 배열도 참조형

```js
let user1 = {
  name: "Binny",
  hobbies: ["reading", "coding"],
};

user1.hobbies.push("traveling");
```

```less
Stack
┌───────────────────────────────────────────────────────┐
│                         user1                         │
└───────────┬─────────────────────────────┬─────────────┘
            ↓                             ↓
Heap                          또 다른 Heap
┌───────────────────────┐    ┌──────────────────────────┐
│  name: "Binny"        │    │ ["reading", "coding",    │
│  hobbies ─────────────┼───▶│  "traveling"]            │
└───────────────────────┘    └──────────────────────────┘
```

- user1은 Heap에 저장된 객체이고, Stack에는 해당 객체의 주소만 저장된다.
- 객체 내부의 hobbies는 배열(참조형)이므로, Heap의 또 다른 공간에 별도로 저장된다.
- user1.hobbies.push("traveling")을 실행하면, Heap에 있는 배열 자체가 변경된다.
- 즉, 객체 내부의 참조형 프로퍼티도 주소를 통해 직접 접근되고 수정될 수 있다.

<br>

### 가비지 컬렉션(Garbage Collection), 참조 카운트(Reference Count)

```js
let num = {
  x: 10,
  y: [3, 4],
};

num.y = "string";
```

```less
Stack
┌───────────────────────────────────────────────────────┐
│                          num                          │
└───────────┬─────────────────────────────┬─────────────┘
            ↓                             ↓
Heap                          또 다른 Heap
┌───────────────────────┐    ┌──────────────────────────┐
│  x: 10                │    │                          │
│  y ───────────────────┼───▶│ [3, 4]                   │
└───────────────────────┘    └──────────────────────────┘


num.y = "string";


Stack
┌───────────────────────────────────────────────────────┐
│                          num                          │
└───────────┬───────────────────────────────────────────┘
            ↓
Heap
┌───────────────────────┐
│  x: 10                │
│  y: "string"          │      [3, 4]: 참조 카운트 0
└───────────────────────┘      → 가비지 컬렉터가 정리
```

- 참조형 데이터는 참조가 끊기면 메모리에서 제거된다. 이것이 자바스크립트의 자동 메모리 관리 원리 중 하나다.
- 아무도 참조하지 않으면 → 참조 카운트 0 → 가비지 컬렉션의 대상이 되어 메모리에서 제거된다.
- 이처럼 자바스크립트는 개발자가 직접 메모리를 해제하지 않아도, 가비지 컬렉션이 자동으로 사용되지 않는 데이터를 정리해준다.

<br>

### Primitive vs Reference

#### Primitive 기본형

- 값을 직접 저장
- 데이터 할당 속도가 빠르다
- 값 비교 시 모든 값을 일일이 비교해야 하므로 비교 비용이 크다.
- 값이 변경될 때마다 새로 할당되므로, 메모리 낭비가 발생할 수 있다.
- 기본형 데이터는 불변 값이다. 값 자체를 변경하지 않고, 새로운 값으로 재할당된다.

#### Reference 참조형

- 값을 저장하지 않고, Heap에 저장된 데이터의 주소만 저장한다.
- 데이터 할당 시 주소를 참조하기 때문에 속도가 느릴 수 있다.
- 주소만 비교하면 되므로 비교가 빠르다.
- 여러 참조가 같은 객체를 공유하면, 불필요한 데이터 중복 없이 메모리를 효율적으로 사용할 수 있다.

<br>

## 불변 객체 (Immutable Object)

객체를 복사한 줄 알았지만, 실제로는 같은 객체를 참조하고 있어 복사본을 수정하면 원본도 함께 바뀌는 경우가 있다. 예를 들어, React에서는 setState를 사용할 때 기존 상태를 직접 수정하지 않고, 항상 새로운 객체로 대체해야 상태 변경이 정상적으로 감지된다.

- 이러한 문제를 피하려면, 기존 객체를 수정하지 않고, 항상 새로운 객체를 생성해서 사용해야 한다.
- 이렇게 원본을 유지한 채 새로운 객체를 만들어 사용하는 방식을 불변 객체라고 하며, React, Redux 등에서 상태 변경을 추적하고 비교를 최적화하는 데 널리 활용된다.

<br>

### 불변 객체와 복사의 깊이

불변 객체를 구현할 때, 단순히 `...` 연산자나 `Object.assign()`을 사용하면 `얕은 복사`만 이루어진다. 이 경우 바깥 객체는 새롭게 만들어지지만, 내부의 중첩된 객체나 배열은 여전히 원본을 참조하고 있어서 완전한 불변성을 보장하지 못한다.

```js
const state = {
  user: { name: "Binny" },
  items: ["a", "b"],
};

const copied = { ...state }; // 얕은 복사
copied.user.name = "Hoon";

console.log(state.user.name); // Hoon ← 원본도 함께 바뀜
```

- copied와 state는 user 객체를 공유하고 있기 때문에, 하나를 수정하면 다른 하나도 영향을 받는다.
- 이처럼 얕은 복사의 한계를 극복하려면, `깊은 복사`를 사용해야 한다.
  깊은 복사는 객체 내부의 모든 중첩 구조까지 새로운 객체로 복사해 완전한 분리를 만들어낸다.

```js
const deepCopied = JSON.parse(JSON.stringify(state));
deepCopied.user.name = "Hoon";

console.log(state.user.name); // Binny ← 원본은 그대로 유지됨
```

- JSON.parse(JSON.stringify())는 함수, undefined, 순환 참조 등은 복사하지 못하므로 한계가 있다.
- 복잡한 구조에서는 structuredClone() 또는 lodash.cloneDeep() 같은 도구를 사용하는 것이 안전하다.

  이처럼 복사의 깊이에 따라 불변 객체의 신뢰성이 달라지기 때문에, 구조의 복잡도에 맞는 복사를 선택하는 것이 중요하다.
