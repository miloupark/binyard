# 02. References (참조)
변수 선언은 코드의 안정성과 가독성의 출발점이다. 무엇이 변할 수 있고, 무엇이 변하지 않아야 하는 지 명확하게 해야한다.

::: info 🧩 Note

var/let/const를 구분하는 것은 `협업의 안정성과 일관성을 보장하기 위한 약속`이다.
- `var`: 호이스팅과 함수 스코프로 인해 예측이 어렵다.
- `const`: 불변성 사고를 자연스럽게 유도한다.
- `let`: 변화의 의도를 명시적으로 드러낸다.

:::

## 1. 모든 참조에는 `var` 대신 `const`를 사용.

eslint: [prefer-const](https://eslint.org/docs/latest/rules/prefer-const.html), [no-const-assign](https://eslint.org/docs/latest/rules/no-const-assign.html)

```js
// bad
var a = 1;
var b = 2;

// good
const a = 1;
const b = 2;
```

- 왜? 참조를 재할당하지 못하게 함으로써, 의도치 않은 변경이나 버그를 예방한다.   
즉, 읽기 전용 변수를 명확히 구분할 수 있다.

<br>

## 2. 재할당이 필요한 경우에만 `var` 대신 `let`을 사용.

eslint: [no-var](https://eslint.org/docs/latest/rules/no-var.html)

```js
// bad
var count = 1;
if (true) {
  count += 1;
}

// good
let count = 1;
if (true) {
  count += 1;
}
```

- 왜? `let`은 블록 스코프를 가지므로, `var`처럼 함수 전체로 범위가 퍼져버리는 문제를 방지한다.

<br>

## 3. `let`과 `const`는 둘 다 블록 스코프

```js
// const와 let은 선언된 블록 안에서만 존재한다.
{
  let a = 1;
  const b = 1;
}

console.log(a); // ReferenceError
console.log(b); // ReferenceError
```
- `cosnt`, `let`은 선언된 블록 안에서만 존재한다.
- 블록이 끝나면 변수는 사라진다.
- 이로인해 코드가 예측 가능해지고, 버그 추적이 쉬워진다.

<br>

::: info 🧩 Block Scope vs Function Scope

- `var`: 함수 스코프 → `{}` 블록을 무시.
- `let`, `const`: 블록 스코프 → 선언된 블록 내부에서만 유효.
- 함수 스코프는 호이스팅으로 인해 변수의 선언 위치와 실제 동작이 어긋나는 문제가 발생한다.

:::